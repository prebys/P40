\chapter{Ideal Gas}

\section{Introduction}

In this lab, you will construct
a Monte Carlo simulation of a 2-D ideal gas, and show that the
molecular velocities follow the Maxwell-Boltzman distribution.

%For a faster but more challenging path, complete only the problems
%(including optional challenge problems) in Sections~\ref{sec:mcint},
%\ref{sec:mbdist}, and \ref{sec:idealgas}.


\section{Ideal Gas in Two Dimensions}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.65\textwidth]{figs/ideal_gas/mbspeed.pdf} \\
\caption{The Maxwell-Boltzmann distribution, for three different
  temperatures, using the system of units chosen for the numerical
  simulation.}
\label{fig:mbspeed}
\end{center}
\end{figure}

\noindent
For the remainder of this lab, we will calculate the statistical
properties of a simulated ideal gas and compare to the theoretical
prediction.  Our ideal gas will be composed of molecules with mass $m$
and held at temperature $T$.  To keep things simple, we will consider
a two dimensional gas.

A fundamental result from statistical mechanics is that the
propability of finding a single gas molecule in a state with energy
$E$ is proportional to the Boltzman factor:
\begin{displaymath}
P(E) \; \propto \; \exp\left(-\frac{E}{k_{\rm B}T}\right)
\end{displaymath}
where $k_{\rm B}$ is Boltzmann's constant.  Since the ideal gas has no
interactions, its energy is purely kinetic energy, and in two
dimensions this is given by:
\begin{displaymath}
E = \frac{1}{2} \, m \, (v_x^2 + v_y^2)
\end{displaymath}
So we can conclude:
\begin{displaymath}
P(v_x, v_y) \; \propto \; \exp\left(-\frac{m\,(v_x^2+v_y^2)}{2k_{\rm B}T}\right)
=
\exp\left(-\frac{m\,v_x^2}{2kT}\right) \cdot \exp\left(-\frac{m\,v_y^2}{2kT}\right)
\end{displaymath}
We can infer that the probability density for the component of velocity in $x$ direction is given by:
\begin{equation}
  \label{eqn:mbvx}
P(v_x) = \sqrt{\frac{m}{2 \pi k_{\rm B} T}} \exp\left(-\frac{m v_x^2}{2k_{\rm B} T}\right)
\end{equation}
where we have calculated the normalization constant such that:
\begin{equation*}
\int_{-infty}^{+\infty} P(v_x) dv_x = 1.
\end{equation*}
Similary:
\begin{equation}
  \label{eqn:mbvy}
P(v_y) = \sqrt{\frac{m}{2 \pi k_{\rm B} T}} \exp\left(-\frac{m v_y^2}{2k_{\rm B} T}\right)
\end{equation}

Now we shall find the PDF associated with a particular speed $v$.  We consider the infinitesimal probability for a particular velocity
\begin{eqnarray*}
P(v_x) P(v_y) \, dv_x \, dv_y
  &=& \frac{m}{2 \pi k_{\rm B} T} \exp\left(-\frac{m (v_x^2+v_y^2)}{2k_{\rm B} T}\right) \, dv_x \, dv_y \\
  &=& \frac{m v}{2 \pi k_{\rm B} T} \exp\left(-\frac{m v^2}{2k_{\rm B} T}\right) \, d\theta \, dv \\
\end{eqnarray*}
where we have changed to polar coordinates $v$ and $\theta$ in the usual manner with area differential $dv_x \, dv_y = v \, dv \, d\theta$.  This allows us to read off the probability density in polar coordintes:
\begin{equation*}
P(v, \theta) = \frac{m v}{2 \pi k_{\rm B} T} \exp\left(-\frac{m v^2}{2k_{\rm B} T}\right) 
\end{equation*}
Integrating over all possible directions $\theta$, we obtain:
\begin{eqnarray}
P(v) &=& \int_0^{2\pi} P(v,\theta) d\theta \nonumber \\
     &=& \int_0^{2\pi} \frac{m v}{2 \pi k_{\rm B} T} \exp\left(-\frac{m v^2}{2k_{\rm B} T}\right) \nonumber \\
P(v) &=& \frac{m v}{k_{\rm B} T} \exp \left(-\frac{m v^2}{2k_{\rm B} T}\right) \label{eqn:mbv}\\
\nonumber
\end{eqnarray}
which is the Maxwell-Boltzmann distribution for an ideal gas in two
dimensions.  This is the probability density for a gas molecule to
have speed $v$. It is illustrated in Fig.~\ref{fig:mbspeed}.  In this
lab, we will create a simple numerical simulation of an ideal gas and
verify that the velocity of the gas follows this distribution.

\section{System of Units}

Choosing an effective system of units is essential for building a
well-behaved numerical simulation.  By now you have hopefully learned
the wisdom of solving problems analytically using only variables,
plugging actual numbers into your equations only if necessary and only
at the very end.  Numerical techniques generally depend on using
actual numerical values, but by making a wise choice for a
computational system of units, we can recover the same universality
and clarity that variables provide to analytic solutions.

Consider the Maxwell-Boltzmann distribution, which involves the following SI values:
\begin{itemize}
\item Boltzmann's constant: $k_{\rm B} = 1.38 \times 10^{-23}~\rm J/K$
\item Molecular masses: e.g. $N_2$ with $m =  4.65 \times 10^{-26}~ \rm kg$.
\item Temperature: e.g. room temperature $T = 293~\rm K$.
\end{itemize}
The smallest number greater than zero that a computer can represent
with a single-precision floating point number is approximately
$10^{-38}$. Representing the SI value of Boltzmann's constant at
$10^{-23}$ uses a large fraction of this precision before we even begin
our calculation.  Numerical algorithms using floating point numbers
work best when the values involved in the calculation are near one.

It is usually best, therefore, to devise an alternate system of units
for any numerical simulation which keeps the values of variables of
interest as near one as possible.  We will call this the numerical
system of units.

To start, we choose a reference temperature near the temperature
we would like to simluate, say $T_0 = 293~\rm K$.  All temperatures in
the simulation will be in units of this reference temperature.  So a
temperature \pyth{T=1.2} in the program will be $1.2~T_0 = 352~\rm K$
in SI units.  Our model also includes mass, so we choose a reference
mass near the mass of the molecules we will be simulating, say $M_0 =
4.65 \times 10^{-26}~ \rm kg$.  A mass {\tt m=2.1} in our program would have
an SI value value of $2.1~M_0 = 9.8 \times 10^{-26}~ \rm kg$.

The physics we will simulate involves Boltzmann's constant $k_{\rm B}$
which will have a value of one in our program.  This sets the
reference energy from our reference temeperature.  For example, an
energy {kT == 3} in our program will have an SI value of $k_{\rm B}
T = 3~k_B~T_0 = 1.21 \times 10^{-20}~J$.  The reference energy and
reference mass together define a reference velocity:
\begin{displaymath}
V_0 = \sqrt{\frac{k_b T_0}{M_0}} = 295~ \rm m/s.  
\end{displaymath}  

The only time the actual values choosen for the numerical system of
units are needed is if you need to convert inputs in SI units to the
numerical system of units, or convert the results of your simulation
to SI units.  In this lab, we will specify all inputs and report all
results using the numerical system of units.  {\bf So there is no need
  for specific values such as $M_0 = 2.32 \times 10^{-25}~\rm kg$ to
  appear anywhere in your program.}  If such values do appear, outside
of comments, you are certainly making a mistake!  If you are living
entirely within the numerical system of units, there is no need to
even define $M_0$: this is how you recover universality in numerical
simulations.\\

\plot Using the numerical system of units:
\begin{python}
# computational system of units:
M  = 1 # mass of gas particles, M0 = 4.65E-26 kg
T  = 1 # Temperature of gas, T0 = 293 K
kb = 1 # Boltzmans constant
\end{python}
and the Maxwell-Boltzman distribution:
\begin{python}
  def mbspeed(v):
      return (M*v / (kb*T))*np.exp(-M*v**2/(2*kb*T))
\end{python}
plot the Maxwell-Boltzman distribution for v = 0 to $5~V_0$.  Compare with Fig.~\ref{fig:mbspeed}.\\

Notice how the relevant velocities for T=1 are near v=1.  This is sign
of good numerical system of units.  Notice also that Boltzmann's
constant or any other small or large numbers in SI units do not appear
anywhere in the code (only in comments).\\

\plot Suppose we set $M_0=10^{-15}~\rm kg$ instead.  Would your plot
in the previous exercise need to be changed?  What about
Fig.~\ref{fig:mbspeed}?  From Fig.~\ref{fig:mbspeed}, read off the
peak of the distribution for T = 2 T0.  What is that in SI units,
assuming $M_0=4.65 \times 10^{-26}~\rm kg$?  What if $M_0=10^{-15}~\rm
kg$?  Do we even need to specify $M_0$ if we do not care about the
specific SI values?  Is choosing a computational system of units with
variables near one the numerical analysis equivalent to solving a
problem using variables only?

\section{Collision Model}

At the heart of your numerical simulation is the collision model.  It
is the collisions of molecules that will allow your simulated gas to
reach thermal equilibrium.  We will use the simple elastic collision
of identical mass particles, as illustrated in Fig.~\ref{fig:collcms}, as our collision model.  We consider particles a and b with velocities $\vec{v_a}$ and
$\vec{v_b}$ in the lab frame.  The velocity of particle a in the CMS frame before the collision is
\begin{displaymath}
\vec{u} = \frac{\vec{v_a} - \vec{v_b}}{2}.
\end{displaymath}
and the velocity of particle b is $-\vec{u}$.

The collision rotates the velocity of particle a by the scattering angle $\theta$ so that the velocity $\vec{w}$ after the collision is
\begin{displaymath}
\begin{pmatrix}
w_x \\
w_y \\
\end{pmatrix}
  =
\begin{pmatrix}
\cos \theta  & -\sin \theta \\
\sin \theta  & \cos \theta \\
\end{pmatrix}
\,
\begin{pmatrix}
u_x \\
u_y \\
\end{pmatrix}
\end{displaymath}
The velocity of particle b after scattering is $-\vec{w}$.

In the lab frame, the velocity of molecule a changes by an amount:
\begin{displaymath}
\Delta \vec{v_a} = \vec{w} - \vec{u}  
\end{displaymath}
and the velocity of molecule b changes by an amount:
\begin{displaymath}
\Delta \vec{v_b} = (-\vec{w}) - (-\vec{u}) = -\Delta \vec{v_a}
\end{displaymath}

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}
\draw[->, line width=1.5, blue] (-3,0) -- (-0.1,0);
\draw[->, line width=1.5, blue] (3,0)  -- (0.1,0);
\draw[->, line width=1.5, red] (0,0) -- (3*0.50,3*0.86) coordinate(A);
\draw[->, line width=1.5, red] (0,0) -- (-3*0.50,-3*0.86) coordinate(B);
\node[right] at (0.5,0.5) {$\theta$};
\node[left] at (-3,0) {a};
\node[right] at (3,0) {b};
\node[above] at (A) {a};
\node[below] at (B) {b};
\node[above] at (-1.5,0) {$\vec{u}$};
\node[above] at (1.5,0) {$-\vec{u}$};
\node[left] at (0.8,1.5) {$\vec{w}$};
\node[left] at (-0.8,-1.4) {$-\vec{w}$};
\end{tikzpicture}
\caption{The collision model in the center-of-mass:  incoming molecule $a$ with velocity $\vec{u}$ collides with the incoming particle $b$ of identical mass with velocity $-\vec{u}$.  Particle $a$ is scattered by angle $\theta$ and leaves with velocity $\vec{w}$, while particle $b$ leaves with velocity $\vec{w}$.  The magnitude of the final and initial velocities are the same:  $|\vec{u}| = |\vec{w}|$.}
\label{fig:collcms}
\end{center}
\end{figure}

\section{Implementing the Collision Model}

Our Python implementation for the collision will be computed in terms
of the components of the velocity vectors of molecule a and molecule
b:
\begin{eqnarray*}
\vec{v_a} &=& 
\begin{pmatrix}
a_x \\
a_y \\
\end{pmatrix} \\
\vec{v_b} &=& 
\begin{pmatrix}
b_x \\
b_y \\
\end{pmatrix} \\
\end{eqnarray*}
We'll use the Python variable names {\tt ax}, {\tt ay}, {\tt bx}, and {\tt by} to refer to $a_x$,  $a_y$,  $b_x$, and $b_y$.  

First calculate the $x$ and $y$ component of $\vec{u}$ as:
\begin{eqnarray*}
u_x &\equiv& \frac{a_x - b_x}{2} \\
u_y &\equiv& \frac{a_y - b_y}{2} \\
\end{eqnarray*}
Then compute the $x$ and $y$ component to the change in velocity of particle a and particle b:
\begin{eqnarray*}
  \Delta a_x &=& (\cos\theta - 1) \, u_x - \sin\theta \, u_y \\
  \Delta a_y &=& (\cos\theta - 1) \, u_y + \sin\theta \,  u_x \\
\end{eqnarray*}
Finally, update the $x$ and $y$ components of the particle velocities to their value after the collision:
\begin{eqnarray*}
  a_x &\to& a_x + \Delta a_x \\
  a_y &\to& a_y + \Delta a_y \\
  b_x &\to& b_x - \Delta a_x \\
  b_y &\to& b_y - \Delta a_y \\
\end{eqnarray*}

\newpage

\plot Implement the collision model as a Python function:
\begin{python}
def collide(ax,ay,bx,by,theta):
    # your code here
    return ax, ay, bx, by # updated values
\end{python}
which takes the lab frame veclocitys of particle a (ax,ay) and b (bx, by) and returns the lab frame velocities after scattering by an angle theta.  Test your code with some simple cases first, rotations by zero,quarter,half,and three quarters of a full turn:
\begin{python}
tau = 2*np.pi # Using 2 pi is like saying twice half-way...
# lab frame is cms, incoming on x axis:
print(np.around(collide(1,0,-1,0,0),2)+0)
print(np.around(collide(1,0,-1,0,tau/4),2)+0)
print(np.around(collide(1,0,-1,0,tau/2),2)+0)
print(np.around(collide(1,0,-1,0,3*tau/4),2)+0)
\end{python}
which should have the output:
\begin{verbatim}
[ 1.  0. -1.  0.]
[ 0.  1.  0. -1.]
[-1.  0.  1.  0.]
[ 0. -1.  0.  1.]
\end{verbatim}
And:
\begin{python}
# lab frame is cms, incoming on	y axis:
print(np.around(collide(0,1,0,-1,0),2)+0)
print(np.around(collide(0,1,0,-1,tau/4),2)+0)
print(np.around(collide(0,1,0,-1,tau/2),2)+0)
print(np.around(collide(0,1,0,-1,3*tau/4),2)+0)
\end{python}
which should have the output:
\begin{verbatim}
[ 0.  1.  0. -1.]
[-1.  0.  1.  0.]
[ 0. -1.  0.  1.]
[ 1.  0. -1.  0.]
\end{verbatim}

\newpage

When debugging code, start with simple test cases.  If you get the
wrong answer, it will be easy to see where the calculation is going
wrong.  Once your code works on the simple tests cases, start adding
more complexity:\\

\plot Test your collision function where the lab frame is not the CMS frame:
\begin{python}
# boost along x axis, incoming on y axis:
print(np.around(collide(1,1,1,-1,0),2)+0)
print(np.around(collide(1,1,1,-1,tau/4),2)+0)
print(np.around(collide(1,1,1,-1,tau/2),2)+0)
print(np.around(collide(1,1,1,-1,3*tau/4),2)+0)
\end{python}
which should output:
\begin{verbatim}
[ 1.  1.  1. -1.]
[0. 0. 2. 0.]
[ 1. -1.  1.  1.]
[2. 0. 0. 0.]
\end{verbatim} \vskip 0.25cm

\plot Test your collision function with randomly choosen values:
\begin{python}
# test with random values:
print(np.around(collide(6.24, 1.78, 3.35, 5.98, 3.19),2))
print(np.around(collide(4.07, 4.69, 1.61, 4.54, 2.46),2))
print(np.around(collide(5.28, 2.99, 4.77, 5.22, 3.15),2))
print(np.around(collide(2.84, 5.37, 5.47, 6.16, 1.59),2))
\end{python}
which should output:
\begin{verbatim}
[3.25 5.91 6.34 1.85]
[1.84 5.33 3.84 3.9 ]
[4.76 5.22 5.29 2.99]
[4.58 4.46 3.73 7.07]
\end{verbatim}

\section{Initializing the Simulated Ideal Gas}

We will be modeling an ideal gas by direct Monte Carlo simulation of
\pyth{NGAS} representative molecules.  The state of your simulation
will be completely contained in two numpy arrays {\tt vx} and {\tt
  vy}, each of length {\tt NGAS}, which contain the velocities of the
particles in units of $V_0 = \sqrt{k_b T_0 / M_0}$.  Remember, the
simulation uses a system of units that should keep velocities near 1,
so values such as 2.2, -3.1, 0.8, -0.01 are all likely, and correspond
to speeds of up to several hundred meters per second in SI units.  On
the other hand, the presence of extremely small values, like 5.3E-23,
and extremely large values like 1.2E18 and -8.2E28 are symptoms of
bugs.\\

\plot Start with a small number of molecules \pyth{NGAS=5}.  Use the
\pyth{np.random.uniform} function to initialize the \pyth{vx} and
\pyth{vy} arrays with random values choosen uniformly in the range
(-2,2).  Print your arrays and see if the output is reasonable.\\

Our simulation is going to grow to contain at least 1000 molecules, so
printing the values of each molecule is not going to work.  So we will want to visualize it as a histogram.\\

\plot Increase NGAS to 1000, and plot the $v_x$ array as a histogram:
\begin{python}
hvx,bins = histogram(vx,bins=20,range=(-5,5))
cbins = (bins[1:]+bins[:-1])/2
plt.errorbar(cbins,hvx,yerr=np.sqrt(hvx),fmt="o")
\end{python}
~\\ \vskip -0.5cm

\plot Plot the $v_y$ distribution as a histogram.\\

Your histograms should reveal that your distribution of velocities is
flat, just like in Fig.~\ref{fig:histpdf}.  The gas molecules have not
yet reached thermal equilibrium with each other!

\section{Collisions of an Ideal Gas}

To reach thermal equilibrium, you'll need to simulate collisions
betweens pairs of molecules in your gas.  For each collision, do the following:
\begin{itemize}
 \item Choose two molecules at random as particles $a$ and $b$. (See {\tt np.random.choice}.)
 \item Choose a random value $\theta$ uniformly in the range $[0,2\pi]$ (See {\tt np.random.uniform}.)
 \item Call your collision function with components of the velocity vectors for particles $a$ and $b$ and the scattering angle $\theta$.
 \item Update the velocity of particles $a$ and $b$ from the return value of your collision funciton
\end{itemize}   
For this model, you will need about 10 times as many collisions as gas
molecules in order to reach thermal equilibrium.\\

\plot For \pyth{NGAS=1000} moleculres, simulated \pyth{NCOLL=10000}
collisions using the algorithm described above.  Plot the vx and vy
distributions as a histogram:
\begin{python}
hvx,bins = histogram(vx,bins=20,range=(-5,5))
hvy,bins = histogram(vy,bins=20,range=(-5,5))
cbins = (bins[1:]+bins[:-1])/2
plt.errorbar(cbins,hvx,yerr=np.sqrt(hvx),fmt="bo",label="vx")
plt.errorbar(cbins,hvy,yerr=np.sqrt(hvx),fmt="ro",label="vy")
plt.xlabel("Velocity (V0)")
plt.ylabel("Molecules")
plt.legend()
\end{python}

\section{Temperature of an Ideal Gas}

The temperature of the gas is related to the mean kinetic energy by:
\begin{equation}
\label{eqn:kt}
k_b T = m \, \frac{\braket{v_x^2} + \braket{v_y^2}}{2}  
\end{equation}  
You can estimate $\braket{v_x^2}$ from your simulation as {\tt np.mean(vx**2)}.\\

\plot Estimate $kT$ of the gas using Equation~\ref{eqn:kt} before and after simulating collisions.
The values should remain near the expected value 4/3.


\section{The Maxwell-Boltzmann Distribution}
\label{sec:mbdist}


In this section, you'll reproduce the instructor plots of
Fig.~\ref{fig:mbinst} using your own numerical simulation.\\

\begin{figure}[htbp]
\begin{center}
  \begin{tabular}{cc}   
  \includegraphics[width=0.45\textwidth]{figs/maxwellboltzman/mbinstv.pdf} &
  \includegraphics[width=0.45\textwidth]{figs/maxwellboltzman/mbinstvxvy.pdf} \\
  (a) & (b) \\
  \end{tabular}
\caption{Instructor plots.}
\label{fig:mbinst}
\end{center}
\end{figure}

\plot After your simulation reaches equilibrium, plot two histograms,
one with $v_x$ and one with $v_y$, with an approriate range and 10
bins.  Directly compare your histograms with the PDF from
Equation~\ref{eqn:mbvx}, scaled appropriately.  The results should
resemble the right side of Fig.~\ref{fig:mbinst}, which were produced
with {\tt NGAS=10000}.\\

\plot After your simulation reaches equilibrium, fill a histograms
with the magnitude of the velocity $v$, with an approriate range and
10 bins.  Compare with the prediction from Equation~\ref{eqn:mbv}.
The results should resemble the left side of Fig.~\ref{fig:mbinst},
which were produced with {\tt NGAS=10000}.\\

\section{Ideal Gas Law}
\label{sec:idealgas}

%This section contains only optional challenge problems.  Only minimal
%instructor help will be available for these problems.\\

\plot (Optional Challenge)  Implement a function which scales the
velocities $v_x$ and $v_y$ by an appropriately choosen factor to set
the temperature of the gas to any desired temperature $T$.  Set the
temperature to $1~T_0$, and show that the gas follows the
Maxwell-Boltzman distribution for $T=1~T_0$.\\

The ideal gas law for a 2-D gas of $N$ molecules at temperature $T$ is
\begin{displaymath}
  Q A = N \, k_{\rm b} T
\end{displaymath}
where $Q$ is the 2-D analog for pressure: a force per unit distance.
We'll consider a rectangular region of gas with height $H$ and length
$L$.  In this case, the ideal gas law becomes:
\begin{displaymath}
  F L = N \, k_{\rm b} T
\end{displaymath}
where $F$ is the total outward force acting on a each boundary of height $H$.

Our computational system of units will be extended to include a
distance $L_0$.  As long as we don't need to convert to SI units,
there is no need for us to specify $L_0$ in meters.  The units of time
are $L_0/V_0$.  The time it takes for a molecule to travel a distance
$L$ is approximately $1~L_0/V_0$, so we will step our simulation in
steps of about $\tau=0.01~L_0/V_0$.

To model the ideal gas law, we will extend our simulation to include
the $x$-position of the gas molecules.  To keep things simple, we will
simulate the motion along the $x$-axis after we have simulated
collisions and reached thermal equilibrium.

Start by generating \pyth{NGAS} $x$-positions uniformly from 0 to $L$.
Set the total momentum transferred ($\Delta p$) to zero.  During each time step,
update each $x$ value to $x + \tau \, v_x$.  For each molecule outside
the boundaries:
\begin{itemize}
 \item For $x<0$ set $x \to -x$
 \item For $x>L$ set $x \to 2L-x$
 \item Or handle both cases at once with:  $x \to (2L-x) \bmod L$
 \item Add $2 M |p_x|$ to the total momentum transferred $\Delta p$
 \item Set $v_x \to -v_x$ 
\end{itemize}   
After $N$ time steps of size $\tau$, the average force on each wall wil be given by:
\begin{displaymath}
F = \frac{\Delta p}{2 N \tau}
\end{displaymath}
If you use boolean masks effectively, you can implement this algorithm
with only a single for loop, which is needed to apply the $N$ time
steps.\\

\plot (Optional Challenge) Calculate the outward force on the wall of
the container for $L = 1 L_0$ and $T = 1 T_0$.  Compare to what you
expect from the ideal gas law.\\

\plot (Optional Challenge) Perform your Fource calculation {\em
  before} the gas reaches thermal equilirium.  Does the ideal gas law
require that the gas has reached thermal equilibrium?\\

\plot (Optional Challenge) Plot the simulated outward force on the
wall of container for several different $L$ values.  On the same axis,
plot the expected force as a function of $L$ as well.\\

\plot  (Optional Challenge) Plot the simulated outward force on the
wall of container for several different $T$ values.  On the same axis,
plot the expected force as a function of $T$ as well.\\
